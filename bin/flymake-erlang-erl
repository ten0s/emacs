#!/usr/bin/env escript
-export([main/1]).

main([FileName]) ->
	BaseDir = filename:join(filename:dirname(FileName), ".."),

	DepsDirs = rebar_deps_dirs(BaseDir),
	ErlcOpts = erlc_opts(BaseDir),

	{_, EbinDirs} = lists:mapfoldr(fun(Dir, Acc) -> {0, filelib:wildcard(Dir ++ "/*/ebin") ++ Acc} end, [], DepsDirs),
	IncludeDirs = lists:map(fun(Dir) -> {i, Dir} end, DepsDirs),

	code:add_paths(EbinDirs),
	CompileResult = compile:file(FileName, ErlcOpts ++ IncludeDirs),
		case CompileResult of
			{ok, _ModuleName} ->
				ok;
			{ok, _ModuleName, Warnings} ->
				print_warnings(FileName, Warnings),
				ok;
			{error, Errors, Warnings} ->
				print_errors(FileName, Errors),
				print_warnings(FileName, Warnings),
				error
		end,
		io:format("~p~n", [CompileResult]).

%%%
%%% Specific
%%%

skip_error(_) -> false.

skip_warning(_) -> false.

fix_line_number(none) -> 1;
fix_line_number(Line) -> Line.

%%%
%%% Generic
%%%

rebar_deps_dirs(BaseDir) ->
	case file:consult(filename:join(BaseDir, "rebar.config")) of
		{ok, Terms} ->
			OtpDirs = ["./include"],
			LibDirs = proplists:get_value(lib_dirs, Terms, []),
			DepsDir = proplists:get_value(deps_dir, Terms, "deps"),
			UniqDirs = sets:to_list(sets:from_list(OtpDirs ++ DepsDir ++ LibDirs)),
			lists:map(fun(Dir) -> filename:join(BaseDir, Dir) end, UniqDirs);
		{error, _} ->
            []
	end.

erlc_opts(_BaseDir) ->
	[
	% some will be by default
	% some will go from rebar, anger, sinan, Emakefile options
	% rebar.config: {erl_opts, [warn_untyped_record]}.
	strong_validation,
	{warn_format, 1},
	warn_export_all,
	warn_export_vars,
	warn_shadow_vars,
	warn_obsolete_guard,

	warn_unused_import,
	warn_unused_function,
	warn_unused_variable,
	warn_deprecated_function,
	%warn_missing_spec, % ext opts ???

	warn_unused_vars,
	warn_unused_record,
	warn_exported_vars,
	%warn_untyped_record, % record `...' has field(s) without type information -> ext opts
	warn_bif_clash,

	return_errors,
	return_warnings].

%% the `file:format_error' returns the error description in the `line: description' format.
%% here only the `description' is returned.
error_description(Error) ->
	tl(lists:dropwhile(fun(C) -> C =/= 32 end, file:format_error(Error))).

print_errors(_, []) -> ok;
print_errors(FileName, [{_FileName, Errors} | _]) ->
	FilteredErrors = lists:filter(fun(E) -> not skip_error(E) end, Errors),
	lists:foreach(
		fun(Error) ->
			print_error(FileName, Error)
		end,
		FilteredErrors).

print_error(FileName, {Line, _Mod, _Term} = Error) ->
	Description = error_description(Error),
	FixedLine = fix_line_number(Line),
	print_error(FileName, FixedLine, Description).

print_error(FileName, Line, Description) ->
	io:format("~s:~p: ~s~n", [FileName, Line, Description]).

print_warnings(_, []) -> ok;
print_warnings(FileName, [{_FileName, Warnings} | _]) ->
	FilteredWarnings = lists:filter(fun(W) -> not skip_warning(W) end, Warnings),
	lists:foreach(
		fun(Warning) ->
			print_warning(FileName, Warning)
		end,
		FilteredWarnings).

print_warning(FileName, {Line, _Mod, _Term} = Error) ->
	Description = error_description(Error),
	FixedLine = fix_line_number(Line),
	print_warning(FileName, FixedLine, Description).

print_warning(FileName, Line, Description) ->
	io:format("~s:~p: warning: ~s~n", [FileName, Line, Description]).
