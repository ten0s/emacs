#!/usr/bin/env escript
-export([main/1]).

main([FileName]) ->
	case file:read_file(FileName) of
		{ok, HrlContent} ->
			%% precede with the module name, so now this is a real erlang module.
			ErlContent = <<
				<<"-module(test_inc).\n">>/binary,
				HrlContent/binary
			>>,
			%% append an erlang extention, so the `compile:file' won't complain.
			NewFileName = FileName ++ ".erl",
			case file:write_file(NewFileName, ErlContent) of
				ok ->
					AbsFileName = filename:absname(FileName),
					%% erl-hrl share begin
					BaseDir = filename:dirname(filename:dirname(AbsFileName)),

					DepsDirs = deps_dirs(BaseDir),
					ErlcOpts = erlc_opts(BaseDir),

					{_, EbinDirs} = lists:mapfoldr(fun(Dir, Acc) -> {0, filelib:wildcard(Dir ++ "/*/ebin") ++ Acc} end, [], DepsDirs),
					IncludeDirs = lists:map(fun(Dir) -> {i, Dir} end, DepsDirs),
					%% erl-hrl share end

					code:add_paths(EbinDirs),
					CompileResult = compile:file(NewFileName, ErlcOpts ++ IncludeDirs),
					file:delete(NewFileName),
					case CompileResult of
						{ok, _ModuleName} ->
							ok;
						{ok, _ModuleName, Warnings} ->
							print_warnings(FileName, Warnings),
							ok;
						{error, Errors, Warnings} ->
							print_errors(FileName, Errors),
							print_warnings(FileName, Warnings),
							error
					end,
					io:format("~p~n", [CompileResult]);
				{error, Errors} ->
					print_errors(FileName, Errors),
					error
			end;
		{error, Errors} ->
			print_errors(FileName, Errors),
			error
	end.

%%%
%%% Specific
%%%

%% skip errors that might occur in pure header files.
skip_error({_, _, {spec_fun_undefined, _}}) -> true;
skip_error(_) -> false.

%% skip warnings that might occur in pure header files.
skip_warning({_, _, {unused_record, _}}) -> true;
skip_warning({_, _, {unused_type, _}}) -> true;
skip_warning(_) -> false.

%% appropriately fix line numbers due to the `-module' definition.
fix_line_number(none) -> 1;
fix_line_number(Line) -> Line - 1.

%%%
%%% Generic
%%%

deps_dirs(BaseDir) ->
	OtpStdDirs = absdirs(BaseDir, ["./include", "./deps"]),
	DepsDirs =
		case rebar_deps_dirs(BaseDir) of
			{ok, RebarDepsDirs} ->
				RebarDepsDirs;
			{error, bad_format} ->
				[]; % nothing to do. fix the config file. :(
			{error, not_found} ->
				% sinan, Emakefile, ...
				[]
		end,
	uniq(OtpStdDirs ++ DepsDirs).

rebar_deps_dirs("/") ->
	{error, not_found};
rebar_deps_dirs(BaseDir) ->
	RebarConfig = filename:join(BaseDir, "rebar.config"),
	case filelib:is_file(RebarConfig) of
		true ->
			case file:consult(RebarConfig) of
				{ok, Terms} ->
					LibDirs = proplists:get_value(lib_dirs, Terms, []),
					DepsDir = proplists:get_value(deps_dir, Terms, ["deps"]),
					%% recursively try to find configs in parents directory.
					case rebar_deps_dirs(filename:dirname(BaseDir)) of
						{ok, ParentDirs} ->
							{ok, absdirs(BaseDir, uniq(LibDirs ++ DepsDir ++ ParentDirs))};
						{error, _} ->
							{ok, absdirs(BaseDir, uniq(LibDirs ++ DepsDir))}
					end;
				{error, _} ->
		            {error, bad_format}
			end;
		false ->
			rebar_deps_dirs(filename:dirname(BaseDir))
	end.

erlc_opts(_BaseDir) ->
	[
	% some will be by default
	% some will go from rebar, anger, sinan, Emakefile options
	% rebar.config: {erl_opts, [warn_untyped_record]}.
	strong_validation,
	{warn_format, 1},
	warn_export_all,
	warn_export_vars,
	warn_shadow_vars,
	warn_obsolete_guard,

	warn_unused_import,
	warn_unused_function,
	warn_unused_variable,
	warn_deprecated_function,
	%warn_missing_spec, % ext opts ???

	warn_unused_vars,
	warn_unused_record,
	warn_exported_vars,
	%warn_untyped_record, % record `...' has field(s) without type information -> ext opts
	warn_bif_clash,

	return_errors,
	return_warnings].

uniq(List) ->
	sets:to_list(sets:from_list(List)).

absdirs(BaseDir, RelativeDirs) ->
	lists:map(fun(Dir) -> filename:join(BaseDir, Dir) end, RelativeDirs).

%% the `file:format_error' returns the error description in the `line: description' format.
%% here only the `description' is returned.
error_description(Error) ->
	tl(lists:dropwhile(fun(C) -> C =/= 32 end, file:format_error(Error))).

print_errors(_, []) -> ok;
print_errors(FileName, [{_FileName, Errors} | _]) ->
	FilteredErrors = lists:filter(fun(E) -> not skip_error(E) end, Errors),
	lists:foreach(
		fun(Error) ->
			print_error(FileName, Error)
		end,
		FilteredErrors).

print_error(FileName, {Line, _Mod, _Term} = Error) ->
	Description = error_description(Error),
	FixedLine = fix_line_number(Line),
	print_error(FileName, FixedLine, Description).

print_error(FileName, Line, Description) ->
	io:format("~s:~p: ~s~n", [FileName, Line, Description]).

print_warnings(_, []) -> ok;
print_warnings(FileName, [{_FileName, Warnings} | _]) ->
	FilteredWarnings = lists:filter(fun(W) -> not skip_warning(W) end, Warnings),
	lists:foreach(
		fun(Warning) ->
			print_warning(FileName, Warning)
		end,
		FilteredWarnings).

print_warning(FileName, {Line, _Mod, _Term} = Error) ->
	Description = error_description(Error),
	FixedLine = fix_line_number(Line),
	print_warning(FileName, FixedLine, Description).

print_warning(FileName, Line, Description) ->
	io:format("~s:~p: warning: ~s~n", [FileName, Line, Description]).
