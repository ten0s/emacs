#!/usr/bin/env escript
-export([main/1]).

main([FileName]) ->
	case file:read_file(FileName) of
		{ok, HrlContent} ->
			%% preced with module name, so now this is a real erlang module.
			ErlContent = <<
				<<"-module(test_inc).\n">>/binary,
				HrlContent/binary
			>>,
			%% append erlang extention, so the `compile:file' won't complain.
			NewFileName = FileName ++ ".erl",
			case file:write_file(NewFileName, ErlContent) of
				ok ->
					% better use rebar config first to look at dependency path
					% if rebar config isn't found then use wildcards
					ProjectEbins = deps_ebins("../.."),
					DepsEbins = deps_ebins("../../../deps"),
					%these below seems to work but a little slower.
					%ProjectEbins = filelib:wildcard("../../*/ebin/"),
					%DepsEbins = filelib:wildcard("../../../deps/*/ebin/"),
					code:add_paths(ProjectEbins ++ DepsEbins),
					CompileResult = compile:file(NewFileName, [
						warn_obsolete_guard, warn_unused_import, warn_shadow_vars,
						warn_export_vars, strong_validation, return_errors, return_warnings,
						{i, "."}, {i, "../.."}, {i, "../../../deps"}]),
					file:delete(NewFileName),
					io:format("~p~n", [CompileResult]),
					case CompileResult of
						{ok, _ModuleName} ->
							ok;
						{ok, _ModuleName, Warnings} ->
							print_warnings(FileName, Warnings),
							ok;
						{error, Errors, Warnings} ->
							print_errors(FileName, Errors),
							print_warnings(FileName, Warnings),
							error
					end;
				{error, Errors} ->
					print_errors(FileName, Errors),
					error
			end;
		{error, Errors} ->
			print_errors(FileName, Errors),
			error
	end.

deps_ebins(DepsDir) ->
	case filelib:is_dir(DepsDir) of
		false ->
			[];
		true ->
			{ok, Dirs} = file:list_dir(DepsDir),
			[Ebin || Dir <- Dirs, begin Ebin = DepsDir ++ "/" ++ Dir ++ "/ebin", filelib:is_dir(Ebin) end]
	end.

%% ignore the fake name, skip errors that are ok in header files,
%% and fix line numbers due to the `-module' definition.
print_errors(_, []) -> void;
print_errors(FileName, [{_FileName, Errors} | _]) ->
	FilteredErrors = lists:filter(fun(E) -> not skip_error(E) end, Errors),
	lists:foreach(
		fun(Error) ->
			print_error(FileName, Error)
		end,
		FilteredErrors).

%% skip errors that might occur in pure header files.
skip_error({_, _, {spec_fun_undefined, _}}) -> true;
skip_error(_) -> false.

%% ignore the fake name and fixe line numbers due to the `-module' definition.
print_warnings(_, []) -> void;
print_warnings(FileName, [{_FileName, Warnings} | _]) ->
	FilteredWarnings = lists:filter(fun(W) -> not skip_warning(W) end, Warnings),
	lists:foreach(
		fun(Warning) ->
			print_warning(FileName, Warning)
		end,
		FilteredWarnings).

%% skip warnings that might occur in pure header files.
skip_warning({_, _, {unused_record, _}}) -> true;
skip_warning(_) -> false.

%% the `file:format' returns the error description in the `line: description' format.
%% here only the description is returned.
error_description(Error) ->
	tl(lists:dropwhile(fun(C) -> C =/= 32 end, file:format_error(Error))).

%% appropriately fix line numbers due to either absence of the line number
%% or the `-module' definition.
print_error(FileName, {none, _Mod, _Term} = Error) ->
	Description = error_description(Error),
	print_error(FileName, 1, Description);
print_error(FileName, {Line, _Mod, _Term} = Error) ->
	Description = error_description(Error),
	print_error(FileName, Line - 1, Description).

print_error(FileName, Line, Description) ->
	io:format("~s:~p: ~s~n", [FileName, Line, Description]).

%% appropriately fix line numbers due to the `-module' definition.
print_warning(FileName, {Line, _Mod, _Term} = Error) ->
	Description = error_description(Error),
	print_warning(FileName, Line - 1, Description).

print_warning(FileName, Line, Description) ->
	io:format("~s:~p: Warning: ~s~n", [FileName, Line, Description]).
